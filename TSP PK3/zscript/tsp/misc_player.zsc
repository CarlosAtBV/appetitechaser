const TSP_INITMAXSHIELD = 50;

Class TSP_PlayerPawn_MaxShield : Inventory
{
	Default
	{
		Inventory.MaxAmount 999;
	}
}

Class TSP_PlayerPawn_Shield : Inventory
{
	Default
	{
		Inventory.MaxAmount 999;
	}
}

Class TSP_PlayerPawn_BonusShield : Inventory
{
	Default
	{
		Inventory.MaxAmount 200;
	}
}

Class TSP_PlayerPawn_IPlaySounds : Actor
{
	Default
	{
		RenderStyle "None";
	}
	
	States
	{
		Spawn:
			TNT1 A -1;
			Stop;
	}
}

Class TSP_AngleChecker : Actor
{
	Default
	{
		+NOINTERACTION
	}
	States
	{
		Spawn:
			POSS A -1;
			Stop;
	}
}

Class TSP_Seat : Actor
{
	Default
	{
		+NOGRAVITY
	}
	override bool Used(Actor user)
	{
		if(user is "TSP_PlayerPawn_ZSCBase")
		{
			TSP_PlayerPawn_ZSCBase usie = TSP_PlayerPawn_ZSCBase(user);
			if(usie.pp_sit==null)
			{
				usie.pp_sit = self;
				usie.A_SetSize(2,2);
				usie.pp_sit_oldPos = usie.pos;
				usie.A_SetAngle(angle,SPF_INTERPOLATE);
				usie.A_SetPitch(pitch,SPF_INTERPOLATE);
				return true;
			}
			else
			{
				usie.pp_sit = null;
				usie.A_SetSize(GetDefaultByType(usie.GetClass()).radius,GetDefaultByType(usie.GetClass()).height);
				usie.SetOrigin(usie.pp_sit_oldPos,false);
				usie.player.viewheight = usie.viewheight;
				return true;
			}
		}
		return false;
	}
}

Class TSP_PlayerPawn_ZSCBase : DoomPlayer
{
	bool ptp_wallJump;
	bool ptp_wallJumpReadySound;
	
	int ptp_wallJumps;
	
	int pp_gamemode;
	bool pp_meleestart;
	int pp_shieldHitDelay;
	bool pp_shieldLowSound;
	
	bool pp_traitMode;
	
	int pp_initShield;
	
	string pp_notification;
	int pp_notificationTime;
	
	TSP_Seat pp_sit;
	
	Property StartShield : pp_initShield;
	
	TSP_GlobalVariables gvars;
	
	double oldVelZ;
	
	Actor pp_slingTarget;
	
	string pp_menuDesc;
	string pp_menuTitle;
	Property DisplayDescription : pp_menuDesc;
	Property DisplayTitle : pp_menuTitle;
	
	int pp_playerpresflags;
	//flagdef ModFireMode: pp_playerpresflags, 0;
	flagdef BountyHuntersOnly: pp_playerpresflags, 1;
	
	int pp_freezeMe;
	
	bool pp_hasCrouchSlid;
	
	Default
	{
		DamageFactor "MagSlam", 0.0;
	}
	
	override void GiveDefaultInventory()
	{
		pp_gamemode = CVar.GetCVar("tsp_gamemode").GetInt();
		pp_meleestart = CVar.GetCVar("tsp_fistsstart").GetBool()||CVar.GetCVar("tsp_meleesupreme").GetBool();
		super.GiveDefaultInventory();
		
		if(pp_gamemode==1)
		{
			OnBountyHunterLoadout();
		}
		else
		{
			OnStandardLoadout();
		}
		
		GiveInventory("TSP_PlayerPawn_Shield",pp_initShield);
		GiveInventory("TSP_PlayerPawn_MaxShield",pp_initShield);
		
		GiveInventory("TSP_GlobalDollars",TSP_STARTINGMONEY);
		GiveInventory("MeleeButtonActor",1);
		GiveInventory("StartMelee",1);
		GiveInventory("StopMelee",1);
		
		PickWeapon(pp_meleestart,true);
		
		Console.Printf(""..GetClassName());
	}
	
	virtual void OnStandardLoadout()
	{
		ClearInventory();
		Console.Printf("\c[TSPYeller]APPLYING STANDARD LOADOUT TEST");
	}
	virtual void OnBountyHunterLoadout()
	{
		ClearInventory();
		for (int i = 0; i < AllActorClasses.Size(); i++)
		{
			let fucker = (Class<Inventory>)(AllActorClasses[i]);
			if(fucker is "Key")
			{
				GiveInventory(fucker,1);
			}
		}
		Console.Printf("\c[TSPGreen]APPLYING BOUNTY HUNTER LOADOUT TEST");
	}
	
	void CheckWeaponFire ()
	{
		let player = self.player;
		let weapon = player.ReadyWeapon;

		if (weapon == NULL)
			return;

		// Check for fire. Some weapons do not auto fire.
		if ((player.WeaponState & WF_WEAPONREADY) && (player.cmd.buttons & BT_ATTACK))
		{
			if (!player.attackdown || !weapon.bNoAutofire)
			{
				player.attackdown = true;
				FireWeapon (NULL);
				return;
			}
		}
		else if ((player.WeaponState & WF_WEAPONREADYALT) && (player.cmd.buttons & BT_ALTATTACK))
		{
			if (!player.attackdown || !weapon.bNoAutofire)
			{
				player.attackdown = true; //this was commented out before for somer eason so pelase beocm epeic
				FireWeaponAlt (NULL);
				return;
			}
		}
		else
		{
			player.attackdown = false;
		}
	}
	
	override void FireWeaponAlt (State stat)
	{
		/*if (player.Bot == null && bot_observer)
		{
			return;
		}*/

		let weapn = player.ReadyWeapon;
		//[Py] added this shit
		if (weapn == null)
		{
			return;
		}
		
		if(weapn is "TSP_Weapon_Core")
		{
			if(weapn.FindState('TraitAltFire') == null && !weapn.CheckAmmo (Weapon.AltFire, true))
			{
				return;
			}
		}
		else
		{
			if(weapn.FindState('AltFire') == null || !weapn.CheckAmmo (Weapon.AltFire, true))
			{
				return;
			}
		}

		player.WeaponState &= ~WF_WEAPONBOBBING;
		PlayAttacking ();
		weapn.bAltFire = true;

		if (stat == null)
		{
			stat = weapn.GetAltAtkState(!!player.refire);
		}
		
		if(stat!=null) //[Py] bullshit shit
		{
			player.SetPsprite(PSP_WEAPON, stat);
		}
		
		if (!weapn.bNoAlert)
		{
			SoundAlert (self, false);
		}
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		//pp_gamemode = CVar.GetCVar("tsp_gamemode").GetInt();
		
		gvars = TSP_GlobalVariables.Get();
		gvars.tsp_employer = 0;
	}
	
	void notifyMessage (string message, int time = 70)
	{
		pp_notification = message;
		pp_notificationTime = time;
	}
	
	override int DamageMobj (Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if(FindInventory("TSP_Upgrade_ARC_Tank"))
		{
			Console.Printf("hell yea");
			damage *= 0.75;
		}
		
		pp_shieldHitDelay = 35*5;
		
		if(mod!='Suicide' && CountInv("TSP_PlayerPawn_Shield"))
		{
			int truDamage = damage;
			damage = 0;
			
			TakeInventory("TSP_PlayerPawn_Shield",truDamage);
			A_PlaySound("shield/hit",CHAN_BODY);
			if(CountInv("TSP_PlayerPawn_Shield")<1)
			{
				A_PlaySound("shield/depleted",CHAN_BODY);
			}
			A_SetBlend("#56E7FF", 0.1, 8, "#56E7FF", 0.0);
			return 0;
		}
		
		return super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}
	
	int sign (int numby)
	{
		if(numby>0)
		{
			return 1;
		}
		else if (numby<0)
		{
			return -1;
		}
		return 0;
	}
	
	Actor theZoop;
	TSP_EnemyTargeter myZooper;
	Actor pp_slingStore;
	
	void searchForZoopTarget()
	{
		pp_traitMode = player.cmd.buttons & BT_USER1;
		
		/*if(!(player.oldbuttons & BT_USER1))
		{
			theZoop = null;
		}*/
		theZoop = null;
		
		if(pp_traitMode)
		{
			FLineTraceData traceStuff;
			//Console.Printf(""..angley);
			LineTrace(angle, 512, pitch, 0, 41.0, 0.0, 0.0, traceStuff);
			if(traceStuff.HitActor!=null)
			{
				let thisFucker = traceStuff.HitActor;
				if(thisFucker.bShootable&&thisFucker.health>0)
				{
					theZoop = thisFucker;
					myZooper.SwitchTarget(thisFucker);
				}
			}
		}
	
		/*if((theZoop==null||theZoop!=oldZoop)&&oldZoop!=null)
		{
			Console.Printf("Shart");
			oldZoop.Translation = GetDefaultByType(oldZoop.GetClass()).Translation;
			oldZoop.bBRIGHT = GetDefaultByType(oldZoop.GetClass()).bBRIGHT;
		}
		
		oldZoop = theZoop;*/
	}
	
	Vector3 pp_sit_oldPos;
	
	override void Tick ()
	{
		oldVelZ = vel.z;
		
		if (!player || !player.mo || player.mo != self)
		{
			Super.Tick();
			return;
		}
		
		if(pp_freezeMe>0)
		{
			pp_freezeMe--;
			bNoGravity = true;
		}
		bNoDamage = (pp_freezeMe>0);
		bDontThrust = (pp_freezeMe>0);
		
		Super.Tick();
		
		if(health>0)
		{
			if(pp_shieldHitDelay>0)
			{
				pp_shieldHitDelay--;
			}
			else if (CountInv("TSP_PlayerPawn_Shield")<CountInv("TSP_PlayerPawn_MaxShield"))
			{
				GiveInventory("TSP_PlayerPawn_Shield",1);
			}
		}
		
		if(pp_notificationTime>0)
		{
			pp_notificationTime--;
		}
		
		/*if(pp_enemyTargeter==null)
		{
			pp_enemyTargeter = TSP_EnemyTargeter(Spawn("TSP_EnemyTargeter",pos));
		}*/
		
		/*if(theZoop!=null)
		{
			if(pp_enemyTargeter.follower==null)
			{
				pp_enemyTargeter.SetOrigin(theZoop.pos, false);
			}
			pp_enemyTargeter.follower = theZoop;
		}
		else
		{
			pp_enemyTargeter.follower = null;
		}*/
		
		if(pp_slingTarget)
		{
			if(pp_slingTarget.health<1)
			{
				pp_slingTarget=null;
			}
			else if(Distance3D(pp_slingTarget)-pp_slingTarget.radius<64)
			{
				if(pp_SlingTarget.CountInv("TSP_EnemyHandler_IsSupered"))
				{
					pp_freezeMe = pp_SlingTarget.CountInv("TSP_EnemyHandler_IsSupered")/2;
				}
				pp_slingTarget=null;
				A_Stop();
			}
		}
		
		searchForZoopTarget();
		if(myZooper==null)
		{
			myZooper = TSP_EnemyTargeter(Spawn("TSP_EnemyTargeter"));
			myZooper.father = self;
		}
		
		if(pp_sit!=null)
		{
			SetOrigin(pp_sit.pos,false);
			player.viewheight = 32;
		}
		
		TSPBobStuff();
		
		TickLogMessages();
	}
	
	override void CheckJump()
	{
		if(oldVelZ==vel.z)
		{
			ptp_wallJumps = 0;
		}
		
		//Console.Printf((pos.z==floorz).." "..(vel.z!=oldVelZ));
		
		if(player.crouchfactor<1.0)
		{
			if(pos.z==floorz&&vel.z!=oldVelZ&&!pp_hasCrouchSlid)
			{
				vel.x*=4;
				vel.y*=4;
				pp_hasCrouchSlid = true;
			}
		}
		else
		{
			pp_hasCrouchSlid = false;
		}
		
		FLineTraceData traceStuff;
		
		int sidedir = sign(player.cmd.sidemove);
		double angley = angle+atan2(-sidedir,sign(player.cmd.forwardmove));//atan2(prev.y - pos.y,prev.x - pos.x)+180;
		//Console.Printf(""..angley);
		LineTrace(angley, (radius+24)*abs(sidedir), 0, 0, 26.0, 0.0, 0.0, traceStuff);
		
		if(traceStuff.HitType == TRACE_HitWall && oldVelZ!=vel.z)
		{
			if(!ptp_wallJumpReadySound)
			{
				A_PlaySound("mantle",CHAN_BODY);
				ptp_wallJumpReadySound = true;
			}
			if(player.cmd.buttons & BT_JUMP && !(player.oldbuttons & BT_JUMP))
			{
				vel = (0,0,0);
				Line bouncedOffLine = traceStuff.HitLine;
				int bouncedSide = traceStuff.LineSide;
				int bounceDir;
				//Console.Printf(""..traceStuff.LineSide);
				
				switch(bouncedSide)
				{
					case 0: bounceDir = 1; break;
					case 1: bounceDir = -1; break;
				}
				
				int bounceAngle = atan2(bouncedOffLine.v1.p.y - bouncedOffLine.v2.p.y, bouncedOffLine.v1.p.x - bouncedOffLine.v2.p.x)+90*bounceDir;
				int bounceOffAngle = bounceAngle+clamp(DeltaAngle(Normalize180(bounceAngle),angle),-68,68);
				//Console.Printf(""..bounceOffAngle);
				Thrust(14,bounceOffAngle/*angle+(25*sidedir)*/);
				A_PlaySound("*jump",CHAN_VOICE);
				vel.z = clamp(12-(ptp_wallJumps/*/1.25*/),0,12);
				ptp_wallJumps++;
			}
		}
		else
		{
			if(ptp_wallJumpReadySound)
			{
				ptp_wallJumpReadySound = false;
			}
		}
		
		super.CheckJump();
	}
	
	override void DeathThink ()
	{
		pp_gamemode = CVar.GetCVar("tsp_gamemode").GetInt();
		
		let player = self.player;
		int dir;
		double delta;

		player.Uncrouch();
		TickPSprites();

		player.onground = (pos.Z <= floorz);
		if (self is "PlayerChunk")
		{ // Flying bloody skull or flying ice chunk
			player.viewheight = 6;
			player.deltaviewheight = 0;
			if (player.onground)
			{
				if (Pitch > -19.)
				{
					double lookDelta = (-19. - Pitch) / 8;
					Pitch += lookDelta;
				}
			}
		}
		else if (!bIceCorpse)
		{ // Fall to ground (if not frozen)
			player.deltaviewheight = 0;
			if (player.viewheight > 6)
			{
				player.viewheight -= 1;
			}
			if (player.viewheight < 6)
			{
				player.viewheight = 6;
			}
			if (Pitch < 0)
			{
				Pitch += 3;
			}
			else if (Pitch > 0)
			{
				Pitch -= 3;
			}
			if (abs(Pitch) < 3)
			{
				Pitch = 0.;
			}
		}
		player.mo.CalcHeight ();
			
		if (player.attacker && player.attacker != self)
		{ // Watch killer
			double diff = deltaangle(angle, AngleTo(player.attacker));
			double delta = abs(diff);
	
			if (delta < 10)
			{ // Looking at killer, so fade damage and poison counters
				if (player.damagecount)
				{
					player.damagecount--;
				}
				if (player.poisoncount)
				{
					player.poisoncount--;
				}
			}
			delta /= 8;
			Angle += clamp(diff, -5., 5.);
		}
		else
		{
			if (player.damagecount)
			{
				player.damagecount--;
			}
			if (player.poisoncount)
			{
				player.poisoncount--;
			}
		}		

		if (pp_gamemode!=1 && (player.cmd.buttons & BT_USE ||
			((multiplayer || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
		{
			if (level.time >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
			{
				player.cls = NULL;		// Force a new class if the player is using a random class
				player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
				if (special1 > 2)
				{
					special1 = 0;
				}
			}
		}
	}
	
	void PlayerFinishLevel (int mode, int flags)
	{
		Console.Printf("shart");
		
		super.PlayerFinishLevel(mode,flags);

		if (pp_gamemode == TSP_GM_HUNTERS && player.playerstate != PST_DEAD)
		{
			player.health = health = SpawnHealth();
			ClearInventory();
			GiveDefaultInventory();
		}
	}
}