const TSP_INITMAXSHIELD = 50;

Class TSP_PlayerPawn_MaxShield : Inventory
{
	Default
	{
		Inventory.MaxAmount 999;
	}
}

Class TSP_PlayerPawn_Shield : Inventory
{
	Default
	{
		Inventory.MaxAmount 999;
	}
}

Class TSP_PlayerPawn_IPlaySounds : Actor
{
	Default
	{
		RenderStyle "None";
	}
	
	States
	{
		Spawn:
			TNT1 A -1;
			Stop;
	}
}

Class TSP_PlayerPawn_ZSCBase : DoomPlayer
{
	bool ptp_wallJump;
	
	
	int pp_gamemode;
	int pp_shieldHitDelay;
	bool pp_shieldLowSound;
	
	int pp_initShield;
	
	Property StartShield : pp_initShield;
	
	TSP_GlobalVariables gvars;
	//property FallingScreamSpeed: FallingScreamMinSpeed, FallingScreamMaxSpeed;
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		GiveInventory("TSP_PlayerPawn_Shield",pp_initShield);
		GiveInventory("TSP_PlayerPawn_MaxShield",pp_initShield);
		gvars = TSP_GlobalVariables.Get();
		gvars.tsp_employer = 0;
	}
	
	override int DamageMobj (Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		pp_shieldHitDelay = 35*5;
		
		if(mod!='Suicide' && CountInv("TSP_PlayerPawn_Shield"))
		{
			int truDamage = damage;
			damage = 0;
			
			TakeInventory("TSP_PlayerPawn_Shield",truDamage);
			A_PlaySound("shield/hit",CHAN_BODY);
			if(CountInv("TSP_PlayerPawn_Shield")<1)
			{
				A_PlaySound("shield/depleted",CHAN_BODY);
			}
			A_SetBlend("#56E7FF", 0.1, 8, "#56E7FF", 0.0);
			return 0;
		}
		
		return super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}
	
	int sign (int numby)
	{
		if(numby>0)
		{
			return 1;
		}
		else if (numby<0)
		{
			return -1;
		}
		return 0;
	}
	
	double oldVelZ;
	
	override void Tick ()
	{
		Super.Tick();
		if (!player || !player.mo || player.mo != self)
		{
			return;
		}
		
		if(oldVelZ==vel.z)
		{
			ptp_wallJump = false;
		}
		
		if(health>0)
		{
			if(pp_shieldHitDelay>0)
			{
				pp_shieldHitDelay--;
			}
			else if (CountInv("TSP_PlayerPawn_Shield")<CountInv("TSP_PlayerPawn_MaxShield"))
			{
				GiveInventory("TSP_PlayerPawn_Shield",1);
			}
		}
		
		FLineTraceData traceStuff;
		
		double angley = angle+atan2(-sign(player.cmd.sidemove),sign(player.cmd.forwardmove));
		Console.Printf(""..angley);
		LineTrace(angley, radius+16, 0, 0, 0.0, 0.0, 0.0, traceStuff);
		
		if(traceStuff.HitType == TRACE_HitWall && oldVelZ!=vel.z && !ptp_wallJump && player.cmd.buttons & BT_JUMP && !(player.oldbuttons & BT_JUMP))
		{
			Thrust(6,angle+(45*sign(player.cmd.sidemove)));
			A_PlaySound("*jump",CHAN_VOICE);
			vel.z = 12;
			ptp_wallJump = true;
		}
		
		oldVelZ = vel.z;
	}
	
	override void DeathThink ()
	{
		pp_gamemode = CVar.GetCVar("tsp_gamemode").GetInt();
		
		let player = self.player;
		int dir;
		double delta;

		player.Uncrouch();
		TickPSprites();

		player.onground = (pos.Z <= floorz);
		if (self is "PlayerChunk")
		{ // Flying bloody skull or flying ice chunk
			player.viewheight = 6;
			player.deltaviewheight = 0;
			if (player.onground)
			{
				if (Pitch > -19.)
				{
					double lookDelta = (-19. - Pitch) / 8;
					Pitch += lookDelta;
				}
			}
		}
		else if (!bIceCorpse)
		{ // Fall to ground (if not frozen)
			player.deltaviewheight = 0;
			if (player.viewheight > 6)
			{
				player.viewheight -= 1;
			}
			if (player.viewheight < 6)
			{
				player.viewheight = 6;
			}
			if (Pitch < 0)
			{
				Pitch += 3;
			}
			else if (Pitch > 0)
			{
				Pitch -= 3;
			}
			if (abs(Pitch) < 3)
			{
				Pitch = 0.;
			}
		}
		player.mo.CalcHeight ();
			
		if (player.attacker && player.attacker != self)
		{ // Watch killer
			double diff = deltaangle(angle, AngleTo(player.attacker));
			double delta = abs(diff);
	
			if (delta < 10)
			{ // Looking at killer, so fade damage and poison counters
				if (player.damagecount)
				{
					player.damagecount--;
				}
				if (player.poisoncount)
				{
					player.poisoncount--;
				}
			}
			delta /= 8;
			Angle += clamp(diff, -5., 5.);
		}
		else
		{
			if (player.damagecount)
			{
				player.damagecount--;
			}
			if (player.poisoncount)
			{
				player.poisoncount--;
			}
		}		

		if (pp_gamemode==0 && (player.cmd.buttons & BT_USE ||
			((multiplayer || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
		{
			if (level.time >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
			{
				player.cls = NULL;		// Force a new class if the player is using a random class
				player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
				if (special1 > 2)
				{
					special1 = 0;
				}
			}
		}
	}
}